package main

import (
	"fmt"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/descriptorpb"
	"sort"

	val "github.com/donkeylichao/protoc-gen-go-validate/validator"
)

const (
	contextPackage = protogen.GoImportPath("context")
	validatorV10   = protogen.GoImportPath("github.com/go-playground/validator/v10")
	validator      = protogen.GoImportPath("github.com/donkeylichao/protoc-gen-go-validate/validator")
)

// generateFile generates a _validate.pb.go file containing kratos errors definitions.
func generateFile(gen *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + "_validate.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)
	g.P("// Code generated by protoc-gen-go-validate. DO NOT EDIT.")
	g.P()
	g.P("package ", file.GoPackageName)

	g.P("var _ = new(", contextPackage.Ident("Context"), ")")
	g.P("var _ = new(", validatorV10.Ident("Validate"), ")")
	g.P("var _ = new(", validator.Ident("ValidateError"), ")")

	g.P()
	if generateFileContent(gen, file, g) == 0 {

		g.Skip()
	}
	return g
}

// generateFileContent generates the kratos errors definitions, excluding the package statement.
func generateFileContent(gen *protogen.Plugin, file *protogen.File, g *protogen.GeneratedFile) int {
	g.P()

	funcCount := 0
	for _, msg := range file.Messages {
		rules := map[string]string{}
		optinals := map[string]bool{}
		nestedMsg := map[string]int{}
		for _, field := range msg.Fields {
			options, _ := field.Desc.Options().(*descriptorpb.FieldOptions)

			if field.Desc.HasOptionalKeyword() {
				optinals[field.GoName] = true
			}

			if field.Desc.Kind() == protoreflect.MessageKind {
				nestedMsg[field.GoName] = 1
			}

			if field.Desc.IsList() {
				nestedMsg[field.GoName] = 2
			}

			ext := proto.GetExtension(options, val.E_Rules)

			if rule, ok := ext.(string); ok {
				if rule != "" {
					rules[field.GoName] = rule
				}
			}
		}

		if len(rules) == 0 {
			continue
		}

		funcCount++

		g.P(fmt.Sprintf("func (m *%s) Validate() error { ctx := context.TODO(); v := v10.New(); ", msg.Desc.Name()))

		for _, name := range sortKeys(nestedMsg) {
			val := nestedMsg[name]
			if val == 2 {
				g.P(fmt.Sprintf(`
				for _, mi:= range m.%v{
					if err := validator.DoValidate(mi, "%s");err != nil { 
						return err
					}
				}`,
					name, name))
			} else {
				g.P(fmt.Sprintf(`
				if err := validator.DoValidate(m.%v, "%s");err != nil { 
					return err
				}
				`,
					name, name))
			}
		}
		for name, rule := range rules {
			if _, ok := optinals[name]; ok {
				g.P(fmt.Sprintf("if m.%v != nil { if err := v.VarCtx(ctx, m.%v, \"%s\"); err != nil { return validator.WrapValidatorError(\"%s\", err)} }", name, name, rule, name))
			} else {
				g.P(fmt.Sprintf("if err := v.VarCtx(ctx, m.%v, \"%s\"); err != nil { return validator.WrapValidatorError(\"%s\", err)} ", name, rule, name))
			}
		}

		g.P("return nil")
		g.P("}")
		g.P()
	}
	return funcCount
}

func sortKeys(m map[string]int) []string {
	keys := make([]string, 0, len(m))
	for k := range m {
		keys = append(keys, k)
	}
	sort.Strings(keys)
	return keys
}